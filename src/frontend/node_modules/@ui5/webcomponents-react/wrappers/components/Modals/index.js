'use client';

import { useIsomorphicLayoutEffect, useSyncRef } from '@ui5/webcomponents-react-base';
import { createRef, useSyncExternalStore } from 'react';
import { createPortal } from 'react-dom';
import { getRandomId } from '../../internal/getRandomId.js';
import { ModalStore } from '../../internal/ModalStore.js';
import { Dialog } from '../../webComponents/Dialog/index.js';
import { Menu } from '../../webComponents/Menu/index.js';
import { Popover } from '../../webComponents/Popover/index.js';
import { ResponsivePopover } from '../../webComponents/ResponsivePopover/index.js';
import { Toast } from '../../webComponents/Toast/index.js';
import { MessageBox } from '../MessageBox/index.js';
import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
function showDialogFn(props, container) {
  const id = getRandomId();
  const ref = /*#__PURE__*/createRef();
  ModalStore.addModal({
    Component: Dialog,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref,
    close: () => {
      if (ref.current) {
        ref.current.open = false;
      }
    }
  };
}
function showPopoverFn(props, container) {
  const id = getRandomId();
  const ref = /*#__PURE__*/createRef();
  ModalStore.addModal({
    Component: Popover,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref,
    close: () => {
      if (ref.current) {
        ref.current.open = false;
      }
    }
  };
}
function showResponsivePopoverFn(props, container) {
  const id = getRandomId();
  const ref = /*#__PURE__*/createRef();
  ModalStore.addModal({
    Component: ResponsivePopover,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref,
    close: () => {
      if (ref.current) {
        ref.current.open = false;
      }
    }
  };
}
function showMenuFn(props, container) {
  const id = getRandomId();
  const ref = /*#__PURE__*/createRef();
  ModalStore.addModal({
    Component: Menu,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref,
    close: () => {
      if (ref.current) {
        ref.current.open = false;
      }
    }
  };
}
function showMessageBoxFn(props, container) {
  const id = getRandomId();
  const ref = /*#__PURE__*/createRef();
  ModalStore.addModal({
    // @ts-expect-error: props type safety is covered by the `props` property
    Component: MessageBox,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref,
    close: () => {
      if (ref.current) {
        ref.current.open = false;
      }
    }
  };
}
function showToastFn(props, container) {
  const ref = /*#__PURE__*/createRef();
  const id = getRandomId();
  ModalStore.addModal({
    Component: Toast,
    props: {
      ...props,
      open: true,
      onClose: event => {
        if (typeof props.onClose === 'function') {
          props.onClose(event);
        }
        ModalStore.removeModal(id);
      }
    },
    ref,
    container,
    id
  });
  return {
    ref
  };
}

// todo: remove this once it's possible initializing popovers with `open=true` again
function ModalComponent({
  modal
}) {
  const [componentRef, modalsRef] = useSyncRef(modal.ref);
  useIsomorphicLayoutEffect(() => {
    const modalElement = modalsRef.current;
    if (modalElement) {
      requestAnimationFrame(() => {
        modalElement.open = true;
      });
    }
  }, []);
  const {
    open: _0,
    ...props
  } = modal.props;

  // @ts-expect-error: ref is supported by all supported modals
  return /*#__PURE__*/_jsx(modal.Component, {
    ...props,
    ref: componentRef,
    "data-id": modal.id
  });
}

/**
 * Utility class for opening modals in an imperative way.
 *
 * These static helper methods might be useful for showing e.g. Toasts or MessageBoxes after successful or failed
 * network calls.
 *
 * **In order to use these helpers, please make sure to render the `Modals` component somewhere in your application tree.**
 *
 * @since 0.22.2
 */
export function Modals() {
  const modals = useSyncExternalStore(ModalStore.subscribe, ModalStore.getSnapshot, ModalStore.getServerSnapshot);
  return /*#__PURE__*/_jsx(_Fragment, {
    children: modals.map(modal => {
      if (modal?.Component) {
        if (modal.container) {
          return /*#__PURE__*/createPortal(/*#__PURE__*/_jsx(ModalComponent, {
            modal: modal
          }, modal.id), modal.container);
        }
        return /*#__PURE__*/_jsx(ModalComponent, {
          modal: modal
        }, modal.id);
      }
    })
  });
}
Modals.displayName = 'Modals';
Modals.showDialog = showDialogFn;
Modals.showPopover = showPopoverFn;
Modals.showResponsivePopover = showResponsivePopoverFn;
Modals.showMenu = showMenuFn;
Modals.showMessageBox = showMessageBoxFn;
Modals.showToast = showToastFn;